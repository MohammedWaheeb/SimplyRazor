@typeparam TModel
@namespace SW.SimplyRazor
@inject SearchyClient searchyService
@inject NavigationManager nav
@inject NotifyService notify
@using SW.Searchy
@using Humanizer

<SimplyNotify Notification="PageIndexRequested" OnReceived="OnPageIndexRequested" />

<CascadingValue Value="filterConfigs" Name="FilterConfigs">
    @ChildContent
</CascadingValue>

<SimplyAlertHub></SimplyAlertHub>
<div class="row">
    <label for="filterSelect" class="col-auto col-form-label">Search</label>
    <div class="col-auto">
        <div class="input-group">
            <SimplySelect @bind-Value="filterValue"
                          EmptyText="Select filter"
                          StringList="@(filterConfigs.Select(e=>e.Text))" />

            <div class="input-group-append">
                <button class="btn btn-outline-secondary" type="button" @onclick="FilterAddOnClick">Add</button>
            </div>
        </div>
    </div>
    <div class="col text-right mb-2">
        <button disabled="@searching" type="submit" class="btn btn-primary" @onclick="SearchOnClick">
            @if (searching)
            {
                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                @:Searching...
            }
            else
            {
                @:Search
            }
        </button>
    </div>
</div>

@for (int i = 0; i < filters.Count; i++)
{
    int index = i;
    <div class="input-group mb-1">
        <div class="input-group-prepend">
            <span class="input-group-text" id="">@filters[index].Text</span>
        </div>
        <SimplySelect @bind-value="filters[index].Operator"
                      EmptyText="Select condition"
                      KeyValuePairList="@(SearchyFilterConfigType.RulesFor(filters[index].Type).ToDictionary((e) => (int)e, (e)=> e.ToString().Humanize()))">

        </SimplySelect>
        @switch (filters[index].Type)
        {
            case SearchyFilterConfigType.String:

                <input type="text" class="form-control" @bind="filters[index].ValueString" />
                break;

            case SearchyFilterConfigType.Int:

                <input @bind="filters[index].ValueInt" type="number" class="form-control" />
                break;

            case SearchyFilterConfigType.Date:

                <input @bind="filters[index].ValueDate" type="date" class="form-control" />
                break;

        }
        <div class="input-group-append">
            <button @onclick="@(e => RemoveFilter(index))" class="btn btn-outline-secondary" type="button"><span class="oi oi-x" /></button>
        </div>
    </div>
}


@code{

    [Parameter]
    public EventCallback<IEnumerable<TModel>> ValueChanged { get; set; }

    [Parameter]
    public RenderFragment ChildContent { get; set; }

    int filterValue;
    List<FilterModel> filters;
    List<ISearchyFilterConfig> filterConfigs { get; set; }

    Task FilterAddOnClick(MouseEventArgs e)
    {
        if (filterValue > 0)
        {
            filters.Add(new FilterModel(filterConfigs[filterValue - 1]));
            filterValue = 0;
        }
        return Task.CompletedTask;
    }

    async Task RemoveFilter(int index)
    {
        if (filters[index].Required)
            await notify.Publish(new UserMessage { Body = "This filter is required for search.", Level = AttentionLevel.Warning });
        else
            filters.RemoveAt(index);
    }


    protected async override Task OnInitializedAsync()
    {
        filters = new List<FilterModel>();
        filterConfigs = new List<ISearchyFilterConfig>();

        searchyService.Client.BaseAddress = new Uri(nav.BaseUri);
        filterConfigs.AddRange(await searchyService.GetFilterConfigs(typeof(TModel).FullName));

        foreach (var fc in filterConfigs)
        {
            if (fc.Default || fc.Required)
                filters.Add(new FilterModel(fc));
        }


    }

    bool searching;

    async Task Search(int pageIndex)
    {
        searching = true;
        var typedFilters = filters.Select(f => (ISearchyFilterTyped)f).ToList();
        var sreq = new SearchyRequest
        {
            Conditions = new List<SearchyCondition> { new SearchyCondition(typedFilters) },
            PageIndex = pageIndex,
            PageSize = 20
        };

        var sres = await searchyService.Search<TModel>(sreq);

        await ValueChanged.InvokeAsync(sres.Result);
        await notify.Publish(new DatalistReady
        {
            Datalist = sres.Result,
            TotalCount = sres.TotalCount,
            Count = sres.Result.Count(),
            PageSize = 20,
            PageIndex = pageIndex
        });

        searching = false;
    }

    async Task SearchOnClick(EventArgs e)
    {
        await Search(0);
    }

    async Task OnPageIndexRequested(PageIndexRequested indexRequested)
    {
        await Search(indexRequested.Index);
    }

    Debouncer StepperDeboucer = new Debouncer(1000); // one second


    private async Task FilterOnInput(ChangeEventArgs args)
    {
        await StepperDeboucer.Debouce(() => { Console.WriteLine(args.Value); });
    }

    private class FilterModel : ISearchyFilterConfig, ISearchyFilterTyped
    {
        public FilterModel(ISearchyFilterConfig isfc)
        {

            Type = isfc.Type;
            Text = isfc.Text;
            Field = isfc.Field;
            Required = isfc.Required;
            Default = isfc.Default;
            Rules = isfc.Rules;
        }

        public object Value { get; set; }
        public SearchyRule Rule { get => (SearchyRule)Operator; set => Operator = (int)value; }
        public string Type { get; set; }
        public string Text { get; set; }
        public string Field { get; set; }
        public ICollection<SearchyRule> Rules { get; set; }
        public bool Required { get; set; }
        public bool Default { get; set; }
        public int Operator { get; set; }
        public bool? ValueBool { get; set; }
        public byte? ValueByte { get; set; }
        public int? ValueInt { get; set; }
        public long? ValueLong { get; set; }
        public decimal? ValueDecimal { get; set; }
        public string ValueString { get; set; }
        public DateTime? ValueDate { get; set; }
        public byte[] ValueByteArray { get; set; }
        public int[] ValueIntArray { get; set; }
        public long[] ValueLongArray { get; set; }
        public string[] ValueStringArray { get; set; }

        //public string Value2 { get; set; }
    }

}